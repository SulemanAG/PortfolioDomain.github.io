<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms and Their Efficiencies</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8fafc;
            color: #1e293b;
        }
        header {
            background-color: #0f172a;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
        }
        section {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: #ffffff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h2 {
            color: #0f172a;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.5rem;
        }
        pre {
            background-color: #f1f5f9;
            padding: 1rem;
            overflow: auto;
            border-radius: 4px;
        }
        .code {
            color: #2563eb;
        }
        .algorithm {
            margin-bottom: 2rem;
        }
        .efficiency {
            font-weight: bold;
            color: #2563eb;
        }
    </style>
</head>
<body>
    <header>
        <h1>Algorithms and Their Efficiencies</h1>
    </header>
    <section>
        <h2>Sorting Algorithms</h2>

        <div class="algorithm">
            <h3>1. Merge Sort</h3>
            <p>
                <strong>Efficiency:</strong> O(n log n) in all cases (best, average, worst).<br>
                <strong>Why It Is Used:</strong> Merge Sort is stable and performs well on large datasets.<br>
                <strong>How It Is Used:</strong> It divides the array into halves, recursively sorts each half, and merges them.
            </p>
            <pre>
<code class="code">function mergeSort(arr) {
    if (arr.length <= 1) return arr;

    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));

    return merge(left, right);
}

function merge(left, right) {
    let sorted = [];
    while (left.length && right.length) {
        if (left[0] < right[0]) {
            sorted.push(left.shift());
        } else {
            sorted.push(right.shift());
        }
    }
    return [...sorted, ...left, ...right];
}
</code>
            </pre>
        </div>

        <div class="algorithm">
            <h3>2. Quick Sort</h3>
            <p>
                <strong>Efficiency:</strong> O(n log n) on average, O(n²) in the worst case.<br>
                <strong>Why It Is Used:</strong> Quick Sort is efficient and performs in-place sorting.<br>
                <strong>How It Is Used:</strong> It selects a pivot and partitions the array around it.
            </p>
            <pre>
<code class="code">function quickSort(arr) {
    if (arr.length <= 1) return arr;

    const pivot = arr[arr.length - 1];
    const left = arr.filter((el, i) => el <= pivot && i !== arr.length - 1);
    const right = arr.filter(el => el > pivot);

    return [...quickSort(left), pivot, ...quickSort(right)];
}
</code>
            </pre>
        </div>

        <div class="algorithm">
            <h3>3. Bubble Sort</h3>
            <p>
                <strong>Efficiency:</strong> O(n²) in the average and worst cases.<br>
                <strong>Why It Is Used:</strong> Simple to implement for small datasets.<br>
                <strong>How It Is Used:</strong> It repeatedly swaps adjacent elements if they are in the wrong order.
            </p>
            <pre>
<code class="code">function bubbleSort(arr) {
    let swapped;
    do {
        swapped = false;
        for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
                swapped = true;
            }
        }
    } while (swapped);
    return arr;
}
</code>
            </pre>
        </div>
    </section>

    <section>
        <h2>Greedy Algorithms</h2>

        <div class="algorithm">
            <h3>1. Prim's Algorithm</h3>
            <p>
                <strong>Efficiency:</strong> O(E log V) using priority queues.<br>
                <strong>Why It Is Used:</strong> To find a Minimum Spanning Tree (MST) of a graph.<br>
                <strong>How It Is Used:</strong> It starts from an arbitrary node and grows the MST by adding the smallest edge.
            </p>
            <pre>
<code class="code">function primsAlgorithm(graph) {
    const mst = [];
    const visited = new Set();
    const edges = [[0, null]];

    while (edges.length) {
        const [weight, to] = edges.shift();

        if (visited.has(to)) continue;
        visited.add(to);
        mst.push([weight, to]);

        for (let [neighbor, weight] of graph[to]) {
            if (!visited.has(neighbor)) {
                edges.push([weight, neighbor]);
                edges.sort((a, b) => a[0] - b[0]);
            }
        }
    }
    return mst;
}
</code>
            </pre>
        </div>

        <div class="algorithm">
            <h3>2. Kruskal's Algorithm</h3>
            <p>
                <strong>Efficiency:</strong> O(E log E) due to sorting edges.<br>
                <strong>Why It Is Used:</strong> To find the MST by adding the smallest edges while avoiding cycles.<br>
                <strong>How It Is Used:</strong> It sorts all edges and uses union-find to add edges to the MST.
            </p>
            <pre>
<code class="code">function kruskalsAlgorithm(edges, numVertices) {
    const sortedEdges = edges.sort((a, b) => a.weight - b.weight);
    const parent = Array.from({ length: numVertices }, (_, i) => i);

    function find(v) {
        if (parent[v] === v) return v;
        return (parent[v] = find(parent[v]));
    }

    function union(v1, v2) {
        const root1 = find(v1);
        const root2 = find(v2);
        if (root1 !== root2) parent[root1] = root2;
    }

    const mst = [];
    for (let { src, dest, weight } of sortedEdges) {
        if (find(src) !== find(dest)) {
            union(src, dest);
            mst.push({ src, dest, weight });
        }
    }
    return mst;
}
</code>
            </pre>
        </div>
    </section>
</body>
</html>
